# stockapp/batch.py
# -*- coding: utf-8 -*-
"""
Batch-k√∂rning (sidopanel):
- V√§lj sortering: A‚Äì√ñ eller √Ñldst TS f√∂rst (sp√•rade TS-kolumner)
- Ange batch-storlek (t.ex. 10): "K√∂r n√§sta N"
- Visar progressbar + "i/X"-text
- Robust default-runner (SEC/Yahoo (+FMP fallback)) via stockapp.sources.fetch_all_fields_for_ticker
- Skriver EJ √∂ver manuella prognosf√§lt ("Oms√§ttning idag"/"Oms√§ttning n√§sta √•r")
- St√§mplar TS_ f√∂r sp√•rade f√§lt n√§r de matas in (√§ven om v√§rdet r√•kar vara samma)
- S√§tter "Senast auto-uppdaterad" + "Senast uppdaterad k√§lla"
"""

from __future__ import annotations

from typing import Callable, Dict, List, Optional, Tuple, Any
import streamlit as st
import pandas as pd
import numpy as np

from .config import (
    TS_FIELDS,
    FINAL_COLS,
    s√§kerst√§ll_kolumner,
    konvertera_typer,
    add_oldest_ts_col,
    now_stamp,
)

from .calc import update_calculations
from . import sources as _sources


# --------------------------------------------------------------------------------------
# Interna hj√§lp-funktioner
# --------------------------------------------------------------------------------------

MANUELL_PROGNOS_FALT = ("Oms√§ttning idag", "Oms√§ttning n√§sta √•r")

def _safe_float(x, default=0.0) -> float:
    try:
        f = float(x)
        if np.isnan(f):
            return default
        return f
    except Exception:
        return default

def _pick_order(df: pd.DataFrame, sort_mode: str) -> List[str]:
    """Bygger ordningslista av tickers utifr√•n vald sortering."""
    if df is None or df.empty or "Ticker" not in df.columns:
        return []

    if sort_mode == "√Ñldst TS f√∂rst":
        work = add_oldest_ts_col(df.copy())
        work = work.sort_values(by=["_oldest_any_ts_fill", "Bolagsnamn", "Ticker"], ascending=[True, True, True])
        order = [str(t).upper().strip() for t in work["Ticker"].tolist()]
        return order

    # default A‚Äì√ñ (bolagsnamn, ticker)
    work = df.sort_values(by=["Bolagsnamn", "Ticker"], ascending=[True, True]).copy()
    return [str(t).upper().strip() for t in work["Ticker"].tolist()]

def _ensure_session_defaults():
    """Initiera state-nycklar som anv√§nds i batchpanelen."""
    ss = st.session_state
    ss.setdefault("batch_sort_mode", "√Ñldst TS f√∂rst")  # eller "A‚Äì√ñ"
    ss.setdefault("batch_size", 10)
    ss.setdefault("batch_order", [])
    ss.setdefault("batch_pointer", 0)
    ss.setdefault("batch_last_sort", ss["batch_sort_mode"])
    ss.setdefault("last_auto_log", {"changed": {}, "misses": {}, "debug": []})

def _apply_auto_fields_to_row(df: pd.DataFrame, row_idx: int, new_vals: Dict[str, Any], source_label: str, changes_map: Dict[str, List[str]]) -> bool:
    """
    Skriv in automatiskt h√§mtade f√§lt i en rad.
    - Skriv EJ manuella prognosf√§lt.
    - TS_ st√§mplas f√∂r sp√•rade f√§lt OM f√§ltet finns i new_vals (√§ven om lika).
    - 'Senast auto-uppdaterad' + 'Senast uppdaterad k√§lla'
    Returnerar True om n√•got v√§rde faktiskt √§ndrades.
    """
    changed = False
    tkr = str(df.at[row_idx, "Ticker"]).strip().upper()
    changed_fields: List[str] = []

    for f, v in (new_vals or {}).items():
        if f in MANUELL_PROGNOS_FALT:
            continue  # l√§mna √•t manuell uppdatering

        if f not in df.columns:
            # skapa kolumn om den saknas
            if any(x in f.lower() for x in ["kurs","oms√§ttning","p/s","utdelning","cagr","antal","riktkurs","aktier","snitt","score","market cap","kassa","skuld"]):
                df[f] = 0.0
            else:
                df[f] = ""

        old = df.at[row_idx, f]
        write_ok = True
        if isinstance(v, (int, float, np.floating)):
            # alla numeriska f√§lt skrivs (√§ven 0.0) f√∂r robusthet? Vi undviker att nolla befintliga bra v√§rden:
            # strategi: skriv om v > 0, annars bara om kolumnen saknas/√§r NaN
            if f.lower().startswith("p/s") or "market cap" in f.lower() or f in ("Utest√•ende aktier",):
                write_ok = (float(v) > 0)
            else:
                write_ok = (f not in ("P/S", "Utest√•ende aktier") and float(v) >= 0)
        elif isinstance(v, str):
            write_ok = (v.strip() != "")

        if not write_ok:
            # st√§mpla √§nd√• TS om sp√•rat f√§lt levererades (utan att skriva)
            ts_col = TS_FIELDS.get(f)
            if ts_col:
                df.at[row_idx, ts_col] = now_stamp()
            continue

        # skriv och markera √§ndrat om skillnad
        if (pd.isna(old) and not pd.isna(v)) or (str(old) != str(v)):
            df.at[row_idx, f] = v
            changed = True
            changed_fields.append(f)

        # TS-st√§mpel om sp√•rat f√§lt finns i nytt payload (alltid ‚Äì √§ven om lika)
        ts_col = TS_FIELDS.get(f)
        if ts_col:
            df.at[row_idx, ts_col] = now_stamp()

    # meta
    df.at[row_idx, "Senast auto-uppdaterad"] = now_stamp()
    df.at[row_idx, "Senast uppdaterad k√§lla"] = source_label

    if changed_fields:
        changes_map.setdefault(tkr, []).extend(changed_fields)

    return changed

def _default_runner(ticker: str) -> Tuple[Dict[str, Any], Dict[str, Any]]:
    """
    Standard-runner: SEC/Yahoo (+FMP fallback) via sources-modulen.
    Returnerar (vals, debug) ‚Äì 'vals' √§r en dict att skriva in i DF.
    """
    debug: Dict[str, Any] = {"src": "SEC/Yahoo/FMP"}
    vals = {}
    try:
        vals = _sources.fetch_all_fields_for_ticker(ticker)
        debug["keys"] = list(vals.keys())
    except Exception as e:
        debug["error"] = str(e)
    return vals or {}, debug

# --------------------------------------------------------------------------------------
# Publikt API ‚Äì Batch-panel i sidopanelen
# --------------------------------------------------------------------------------------

def sidebar_batch_controls(
    df: pd.DataFrame,
    user_rates: Dict[str, float],
    save_cb: Optional[Callable[[pd.DataFrame], None]] = None,
    recompute_cb: Optional[Callable[[pd.DataFrame], pd.DataFrame]] = None,
    runner: Optional[Callable[[str], Tuple[Dict[str, Any], Dict[str, Any]]]] = None,
) -> pd.DataFrame:
    """
    Renderar batch-panel i sidopanelen och hanterar k√∂rningar.
    Returnerar (m√∂jligen) uppdaterad DataFrame.
    """
    _ensure_session_defaults()
    ss = st.session_state

    st.sidebar.subheader("üõ†Ô∏è Batch-uppdatering")

    # V√§lj ordning
    sort_mode = st.sidebar.selectbox("Ordning", ["√Ñldst TS f√∂rst", "A‚Äì√ñ"], index=0 if ss["batch_sort_mode"]=="√Ñldst TS f√∂rst" else 1, key="batch_sort_mode")

    # Storlek
    batch_size = st.sidebar.number_input("Antal i n√§sta batch", min_value=1, max_value=200, value=int(ss["batch_size"]), step=1, key="batch_size")

    # Ber√§kna ordning om ny eller saknas
    if not ss["batch_order"] or ss["batch_last_sort"] != sort_mode:
        order = _pick_order(df, sort_mode)
        ss["batch_order"] = order
        ss["batch_pointer"] = 0
        ss["batch_last_sort"] = sort_mode

    total = len(ss["batch_order"])
    st.sidebar.caption(f"K√∂: {total} tickers")
    st.sidebar.caption(f"N√§sta startindex: {ss['batch_pointer']}")

    # Styra pointer manuellt?
    new_ptr = st.sidebar.number_input("Hoppa till index", min_value=0, max_value=max(0, total-1), value=int(ss["batch_pointer"]), step=1)
    if new_ptr != ss["batch_pointer"]:
        ss["batch_pointer"] = int(new_ptr)

    # Knappar
    colb1, colb2, colb3 = st.sidebar.columns([1,1,1])
    with colb1:
        reset_clicked = st.button("√Öterst√§ll k√∂")
    with colb2:
        preview_clicked = st.button("F√∂rhandsvisa")
    with colb3:
        run_clicked = st.button("K√∂r n√§sta N")

    if reset_clicked:
        ss["batch_order"] = _pick_order(df, sort_mode)
        ss["batch_pointer"] = 0
        st.sidebar.success("K√∂n √•terst√§lld.")

    # F√∂rhandsvisa vilka som k√∂rs
    if preview_clicked or not ss["batch_order"]:
        start = ss["batch_pointer"]
        end = min(total, start + int(batch_size))
        preview = ss["batch_order"][start:end]
        if preview:
            st.sidebar.write("**N√§sta batch:**")
            st.sidebar.write(", ".join(preview))
        else:
            st.sidebar.info("Inget att k√∂ra (k√∂n slut).")

    # K√∂rning
    if run_clicked and ss["batch_order"]:
        start = ss["batch_pointer"]
        end = min(total, start + int(batch_size))
        to_run = ss["batch_order"][start:end]

        if not to_run:
            st.sidebar.info("Inget att k√∂ra (k√∂n slut).")
            return df

        progress = st.sidebar.progress(0.0)
        step_txt = st.sidebar.empty()

        # F√∂r logg
        log = {"changed": {}, "misses": {}, "debug": []}
        any_changed = False

        run_fn = runner or _default_runner
        src_label = "Auto (SEC/Yahoo‚ÜíFMP)"

        # S√§kerst√§ll schema/typer f√∂re skrivning
        df = s√§kerst√§ll_kolumner(df)
        df = konvertera_typer(df)

        for i, tkr in enumerate(to_run):
            step_txt.write(f"Uppdaterar {i+1}/{len(to_run)} ‚Äì **{tkr}**")
            try:
                vals, dbg = run_fn(tkr)
                log["debug"].append({tkr: dbg})

                # hitta rad
                mask = (df["Ticker"].astype(str).str.upper().str.strip() == str(tkr).upper().strip())
                if not mask.any():
                    log["misses"][tkr] = ["Ticker saknas i tabellen"]
                else:
                    idx = df.index[mask][0]
                    # skriv f√§lt med TS och meta
                    changed = _apply_auto_fields_to_row(df, idx, vals, source_label=src_label, changes_map=log["changed"])
                    any_changed = any_changed or changed
            except Exception as e:
                log["misses"][tkr] = [f"error: {e}"]

            progress.progress((i+1)/max(1, len(to_run)))

        # Efter k√∂rning ‚Äì uppdatera ber√§kningar & spara (om callbackar finns)
        if recompute_cb:
            try:
                df = recompute_cb(df)
            except Exception as e:
                st.sidebar.warning(f"Kunde inte r√§kna om formler: {e}")

        if save_cb and any_changed:
            try:
                save_cb(df)
                st.sidebar.success("√Ñndringar sparade.")
            except Exception as e:
                st.sidebar.error(f"Misslyckades spara: {e}")
        else:
            if not any_changed:
                st.sidebar.info("Inga faktiska √§ndringar ‚Äì ingen skrivning.")

        # Flytta pointer
        ss["batch_pointer"] = end
        ss["last_auto_log"] = log

        # Summera
        n_ch = sum(len(v) for v in log["changed"].values())
        st.sidebar.write(f"Klart. √Ñndrade f√§lt totalt: {n_ch}.")
        if log["misses"]:
            st.sidebar.warning(f"Missar p√• {len(log['misses'])} tickers.")

    return df


# --------------------------------------------------------------------------------------
# Hj√§lp-funktion f√∂r huvud-app: k√∂r batch p√• given lista (utan UI)
# --------------------------------------------------------------------------------------

def run_batch_update(
    df: pd.DataFrame,
    user_rates: Dict[str, float],
    tickers: List[str],
    make_snapshot: bool = False,
    save_cb: Optional[Callable[[pd.DataFrame], None]] = None,
    runner: Optional[Callable[[str], Tuple[Dict[str, Any], Dict[str, Any]]]] = None,
) -> Tuple[pd.DataFrame, Dict[str, Any]]:
    """
    K√∂r en batch programatiskt (utan att rita UI). Returnerar (df, log).
    """
    df = s√§kerst√§ll_kolumner(df)
    df = konvertera_typer(df)

    progress = st.sidebar.progress(0.0)
    step_txt = st.sidebar.empty()

    log = {"changed": {}, "misses": {}, "debug": []}
    any_changed = False

    run_fn = runner or _default_runner
    src_label = "Auto (SEC/Yahoo‚ÜíFMP)"

    for i, tkr in enumerate(tickers):
        step_txt.write(f"Uppdaterar {i+1}/{len(tickers)} ‚Äì **{tkr}**")
        try:
            vals, dbg = run_fn(tkr)
            log["debug"].append({tkr: dbg})

            mask = (df["Ticker"].astype(str).str.upper().str.strip() == str(tkr).upper().strip())
            if not mask.any():
                log["misses"][tkr] = ["Ticker saknas i tabellen"]
            else:
                idx = df.index[mask][0]
                changed = _apply_auto_fields_to_row(df, idx, vals, source_label=src_label, changes_map=log["changed"])
                any_changed = any_changed or changed
        except Exception as e:
            log["misses"][tkr] = [f"error: {e}"]

        progress.progress((i+1)/max(1, len(tickers)))

    # R√§kna om
    try:
        df = update_calculations(df, user_rates)
    except Exception as e:
        st.sidebar.warning(f"Kunde inte r√§kna om formler: {e}")

    # Spara
    if save_cb and any_changed:
        try:
            save_cb(df)
            st.sidebar.success("√Ñndringar sparade.")
        except Exception as e:
            st.sidebar.error(f"Misslyckades spara: {e}")
    else:
        if not any_changed:
            st.sidebar.info("Inga faktiska √§ndringar ‚Äì ingen skrivning.")

    return df, log
