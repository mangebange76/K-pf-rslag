# stockapp/compute.py
# -*- coding: utf-8 -*-
"""
Beräkningar, typkonverteringar och tidsstämpling (TS) för appen.
"""

from __future__ import annotations

from typing import Optional, Dict, List
from datetime import datetime, timedelta

import numpy as np
import pandas as pd

from .config import FINAL_COLS, TS_FIELDS

# ------------------------------------------------------------
# Tidshjälpare (Stockholm om pytz finns)
# ------------------------------------------------------------
try:
    import pytz
    TZ_STHLM = pytz.timezone("Europe/Stockholm")
    def now_stamp() -> str:
        return datetime.now(TZ_STHLM).strftime("%Y-%m-%d")
    def now_dt() -> datetime:
        return datetime.now(TZ_STHLM)
except Exception:
    def now_stamp() -> str:
        return datetime.now().strftime("%Y-%m-%d")
    def now_dt() -> datetime:
        return datetime.now()


# ------------------------------------------------------------
# Schema & typkonvertering
# ------------------------------------------------------------
def sakerstall_kolumner(df: pd.DataFrame) -> pd.DataFrame:
    """
    Säkerställ att alla FINAL_COLS finns och fyll med rimliga default.
    """
    for kol in FINAL_COLS:
        if kol not in df.columns:
            if any(x in kol.lower() for x in ["kurs", "omsättning", "p/s", "utdelning", "cagr", "antal", "riktkurs", "aktier", "snitt", "mcap"]):
                df[kol] = 0.0
            elif kol.startswith("TS_"):
                df[kol] = ""
            elif kol in ("Senast manuellt uppdaterad", "Senast auto-uppdaterad", "Senast uppdaterad källa"):
                df[kol] = ""
            else:
                df[kol] = ""
    # ta bort ev. dubblettkolumner
    df = df.loc[:, ~df.columns.duplicated()].copy()
    return df


def migrera_gamla_riktkurskolumner(df: pd.DataFrame) -> pd.DataFrame:
    """
    Mappning från gamla kolumnnamn till nya, behåller värden där nya saknas.
    """
    mapping = {
        "Riktkurs 2026": "Riktkurs om 1 år",
        "Riktkurs 2027": "Riktkurs om 2 år",
        "Riktkurs 2028": "Riktkurs om 3 år",
        "Riktkurs om idag": "Riktkurs idag",
    }
    for old, new in mapping.items():
        if old in df.columns:
            if new not in df.columns:
                df[new] = 0.0
            new_vals = pd.to_numeric(df[new], errors="coerce").fillna(0.0)
            old_vals = pd.to_numeric(df[old], errors="coerce").fillna(0.0)
            mask = (new_vals == 0.0) & (old_vals > 0.0)
            df.loc[mask, new] = old_vals[mask]
            df = df.drop(columns=[old])
    return df


def konvertera_typer(df: pd.DataFrame) -> pd.DataFrame:
    """
    Robust numerisk konvertering av nyckelfält + str för textsfält/TS.
    """
    num_cols = [
        "Utestående aktier", "P/S", "P/S Q1", "P/S Q2", "P/S Q3", "P/S Q4",
        "Omsättning idag", "Omsättning nästa år", "Omsättning om 2 år", "Omsättning om 3 år",
        "Riktkurs idag", "Riktkurs om 1 år", "Riktkurs om 2 år", "Riktkurs om 3 år",
        "Antal aktier", "Årlig utdelning", "Aktuell kurs", "CAGR 5 år (%)",
        "P/S-snitt",
        # ev. marketcap-kolumner om du har dem i FINAL_COLS
        "MCAP nu", "MCAP Q1", "MCAP Q2", "MCAP Q3", "MCAP Q4"
    ]
    for c in num_cols:
        if c in df.columns:
            df[c] = pd.to_numeric(df[c], errors="coerce").fillna(0.0)

    for c in ["Ticker", "Bolagsnamn", "Valuta",
              "Senast manuellt uppdaterad", "Senast auto-uppdaterad", "Senast uppdaterad källa"]:
        if c in df.columns:
            df[c] = df[c].astype(str)

    for c in df.columns:
        if str(c).startswith("TS_"):
            df[c] = df[c].astype(str)

    return df


# ------------------------------------------------------------
# TS-hjälpare
# ------------------------------------------------------------
def _stamp_ts_for_field(df: pd.DataFrame, row_idx: int, field: str, when: Optional[str] = None) -> None:
    """
    Sätter TS-kolumnen för ett spårat fält om den finns.
    """
    ts_col = TS_FIELDS.get(field)
    if not ts_col:
        return
    try:
        df.at[row_idx, ts_col] = when if when else now_stamp()
    except Exception:
        pass


def _note_auto_update(df: pd.DataFrame, row_idx: int, source: str) -> None:
    """
    Sätter auto-uppdaterad-tidsstämpel och källa på raden.
    """
    try:
        df.at[row_idx, "Senast auto-uppdaterad"] = now_stamp()
        df.at[row_idx, "Senast uppdaterad källa"] = source
    except Exception:
        pass


def _note_manual_update(df: pd.DataFrame, row_idx: int) -> None:
    """
    Sätter manuell uppdateringsstämpel (används i formulär-flöden).
    """
    try:
        df.at[row_idx, "Senast manuellt uppdaterad"] = now_stamp()
    except Exception:
        pass


# ------------------------------------------------------------
# Beräkningar
# ------------------------------------------------------------
def uppdatera_berakningar(df: pd.DataFrame, user_rates: dict | None = None) -> pd.DataFrame:
    """
    Beräknar:
      - P/S-snitt (positiva Q1..Q4)
      - 'Omsättning om 2 år' & 'Omsättning om 3 år' från 'Omsättning nästa år' med CAGR-clamp
      - Riktkurser idag/1/2/3 beroende på P/S-snitt och Utestående aktier (miljoner)
    """
    # OBS: user_rates används ej här just nu, men behålls i signaturen för kompatibilitet
    for i, rad in df.iterrows():
        # P/S-snitt
        ps_vals = [rad.get("P/S Q1", 0), rad.get("P/S Q2", 0), rad.get("P/S Q3", 0), rad.get("P/S Q4", 0)]
        ps_clean = [float(x) for x in ps_vals if _safe_pos(x)]
        ps_snitt = round(float(np.mean(ps_clean)), 4) if ps_clean else 0.0
        df.at[i, "P/S-snitt"] = ps_snitt

        # CAGR clamp: >100% → 50%, <0% → 2%
        cagr = _safe_float(rad.get("CAGR 5 år (%)", 0.0))
        just_cagr = 50.0 if cagr > 100.0 else (2.0 if cagr < 0.0 else cagr)
        g = just_cagr / 100.0

        # Framtida omsättning från "Omsättning nästa år"
        oms_next = _safe_float(rad.get("Omsättning nästa år", 0.0))
        if oms_next > 0:
            df.at[i, "Omsättning om 2 år"] = round(oms_next * (1.0 + g), 2)
            df.at[i, "Omsättning om 3 år"] = round(oms_next * ((1.0 + g) ** 2), 2)
        else:
            df.at[i, "Omsättning om 2 år"] = _safe_float(rad.get("Omsättning om 2 år", 0.0))
            df.at[i, "Omsättning om 3 år"] = _safe_float(rad.get("Omsättning om 3 år", 0.0))

        # Riktkurser: kräver Utestående aktier (miljoner) > 0 och P/S-snitt > 0
        aktier_mn = _safe_float(rad.get("Utestående aktier", 0.0))  # miljoner
        if aktier_mn > 0 and ps_snitt > 0:
            # Värdering: (Omsättning (M) * P/S) / (Utest. aktier (M)) = pris per aktie
            df.at[i, "Riktkurs idag"]    = _rk(_safe_float(rad.get("Omsättning idag", 0.0)),         ps_snitt, aktier_mn)
            df.at[i, "Riktkurs om 1 år"] = _rk(_safe_float(rad.get("Omsättning nästa år", 0.0)),     ps_snitt, aktier_mn)
            df.at[i, "Riktkurs om 2 år"] = _rk(_safe_float(df.at[i, "Omsättning om 2 år"]),           ps_snitt, aktier_mn)
            df.at[i, "Riktkurs om 3 år"] = _rk(_safe_float(df.at[i, "Omsättning om 3 år"]),           ps_snitt, aktier_mn)
        else:
            for c in ["Riktkurs idag","Riktkurs om 1 år","Riktkurs om 2 år","Riktkurs om 3 år"]:
                if c in df.columns:
                    df.at[i, c] = 0.0

    return df


def _rk(rev_mn: float, ps: float, shares_mn: float) -> float:
    """
    Riktkurs = (Omsättning (miljoner) * P/S) / (Utest. aktier (miljoner))
    """
    try:
        if rev_mn > 0 and ps > 0 and shares_mn > 0:
            return round((rev_mn * ps) / shares_mn, 4)
    except Exception:
        pass
    return 0.0


def _safe_float(x, default: float = 0.0) -> float:
    try:
        return float(x)
    except Exception:
        return float(default)


def _safe_pos(x) -> bool:
    try:
        return float(x) > 0.0
    except Exception:
        return False


# ------------------------------------------------------------
# Skriv hjälpare (auto-uppdatering, TS & källa)
# ------------------------------------------------------------
def apply_auto_updates_to_row(
    df: pd.DataFrame,
    row_idx: int,
    new_vals: Dict[str, object],
    source: str,
    changes_map: Dict[str, List[str]],
    always_stamp: bool = True,
) -> bool:
    """
    Skriver fält från new_vals till df[row_idx]:
      - skriver endast numeriska värden om > 0 (med undantag för vissa fält),
        strängar skrivs om de ej är tomma.
      - stämplar TS_ för fält i TS_FIELDS
      - sätter 'Senast auto-uppdaterad' + 'Senast uppdaterad källa'
      - om always_stamp=True: TS stämplas även om värdet inte ändras (uppfyller kravet)
    Returnerar True om någon cell i raden ändrades (värdeskillnad), annars False.
    """
    changed_fields: List[str] = []
    wrote_any = False

    for f, v in (new_vals or {}).items():
        if f not in df.columns:
            continue

        # skrivbar logik
        write_ok = False
        if isinstance(v, (int, float, np.floating)):
            # vissa fält får vara 0 (t.ex. utdelning), men P/S och Utestående aktier kräver > 0 för att vara meningsfullt
            if f in ["P/S","P/S Q1","P/S Q2","P/S Q3","P/S Q4","Utestående aktier","Aktuell kurs"]:
                write_ok = (_safe_float(v) > 0.0)
            else:
                write_ok = (_safe_float(v) >= 0.0)
        elif isinstance(v, str):
            write_ok = (v.strip() != "")
        else:
            # andra typer ignoreras
            write_ok = False

        if not write_ok:
            # även om vi inte skriver nytt värde vill vi ev. stämpla TS om always_stamp=True
            if always_stamp and f in TS_FIELDS:
                _stamp_ts_for_field(df, row_idx, f)
                wrote_any = True
            continue

        old = df.at[row_idx, f]
        old_str = "" if pd.isna(old) else str(old)
        new_str = str(v)

        # skriv om olika eller om always_stamp (då vill vi TS även vid samma värde)
        if (old_str != new_str):
            df.at[row_idx, f] = v
            changed_fields.append(f)
            wrote_any = True
            if f in TS_FIELDS:
                _stamp_ts_for_field(df, row_idx, f)
        else:
            # samma värde men vi ska TS-stämpla om fältet är spårat
            if f in TS_FIELDS and always_stamp:
                _stamp_ts_for_field(df, row_idx, f)
                wrote_any = True

    # notera auto-update och källa om vi skrev något (nytt värde eller bara ny TS)
    if wrote_any:
        _note_auto_update(df, row_idx, source)
        # logga endast fält som faktiskt ändrades i värde (ej bara TS)
        if changed_fields:
            tkr = str(df.at[row_idx, "Ticker"]) if "Ticker" in df.columns else f"row{row_idx}"
            changes_map.setdefault(tkr, []).extend(changed_fields)
        return True

    return False


# ------------------------------------------------------------
# Kontroll-vy hjälpare
# ------------------------------------------------------------
def oldest_any_ts(row: pd.Series) -> Optional[pd.Timestamp]:
    """
    Returnerar äldsta (minsta) TS bland alla TS_-kolumner i en rad. None om inga.
    """
    dates: List[pd.Timestamp] = []
    for c in TS_FIELDS.values():
        if c in row and str(row[c]).strip():
            try:
                d = pd.to_datetime(str(row[c]).strip(), errors="coerce")
                if pd.notna(d):
                    dates.append(d)
            except Exception:
                pass
    return min(dates) if dates else None


def add_oldest_ts_col(df: pd.DataFrame) -> pd.DataFrame:
    """
    Lägger till hjälp-kolumner för sortering på äldst TS.
    """
    df2 = df.copy()
    df2["_oldest_any_ts"] = df2.apply(oldest_any_ts, axis=1)
    df2["_oldest_any_ts"] = pd.to_datetime(df2["_oldest_any_ts"], errors="coerce")
    # 2099 som fill för att kunna sortera
    df2["_oldest_any_ts_fill"] = df2["_oldest_any_ts"].fillna(pd.Timestamp("2099-12-31"))
    return df2


def build_requires_manual_df(df: pd.DataFrame, older_than_days: int = 365) -> pd.DataFrame:
    """
    Identifierar bolag som kan kräva manuella åtgärder:
      - saknar något kärnfält (Utest. aktier, P/S, P/S Q1..Q4, Omsättning idag/ nästa år)
      - saknar någon TS för spårade fält
      - äldsta TS äldre än older_than_days
    """
    need_cols = ["Utestående aktier","P/S","P/S Q1","P/S Q2","P/S Q3","P/S Q4","Omsättning idag","Omsättning nästa år"]
    ts_cols = [TS_FIELDS[c] for c in TS_FIELDS if c in need_cols]

    out_rows: List[dict] = []
    cutoff = now_dt() - timedelta(days=int(older_than_days))

    for _, r in df.iterrows():
        missing_val = any((_safe_float(r.get(c, 0.0)) <= 0.0) for c in need_cols)
        missing_ts  = any((not str(r.get(ts, "")).strip()) for ts in ts_cols if ts in r)
        oldest = oldest_any_ts(r)
        oldest_dt = pd.to_datetime(oldest).to_pydatetime() if pd.notna(oldest) else None
        too_old = (oldest_dt is not None and oldest_dt < cutoff)

        if missing_val or missing_ts or too_old:
            out_rows.append({
                "Ticker": r.get("Ticker",""),
                "Bolagsnamn": r.get("Bolagsnamn",""),
                "Äldsta TS": oldest.strftime("%Y-%m-%d") if pd.notna(oldest) else "",
                "Saknar värde?": "Ja" if missing_val else "Nej",
                "Saknar TS?": "Ja" if missing_ts else "Nej",
            })

    return pd.DataFrame(out_rows)


# ------------------------------------------------------------
# Manuella prognoser – TODO-lista
# ------------------------------------------------------------
def manual_forecast_todo(df: pd.DataFrame, limit: int = 50) -> pd.DataFrame:
    """
    Returnerar lista på bolag där just prognosfälten behöver kollas manuellt:
      - “Omsättning idag” och “Omsättning nästa år”
    Sorteras på äldsta TS bland endast dessa två fält.
    """
    cols_needed = ["Omsättning idag", "Omsättning nästa år"]
    ts_cols = [TS_FIELDS.get("Omsättning idag", ""), TS_FIELDS.get("Omsättning nästa år", "")]
    ts_cols = [c for c in ts_cols if c]  # filtrera bort tomma

    rows = []
    for _, r in df.iterrows():
        # äldsta TS bland prognos-fälten
        dts = []
        for tc in ts_cols:
            if tc in r and str(r[tc]).strip():
                d = pd.to_datetime(str(r[tc]).strip(), errors="coerce")
                if pd.notna(d):
                    dts.append(d)
        oldest = min(dts) if dts else pd.NaT

        miss_val = any((_safe_float(r.get(c, 0.0)) <= 0.0) for c in cols_needed)
        miss_ts = any((not str(r.get(tc, "")).strip()) for tc in ts_cols if tc in r)

        if miss_val or miss_ts:
            rows.append({
                "Ticker": r.get("Ticker",""),
                "Bolagsnamn": r.get("Bolagsnamn",""),
                "TS_Omsättning idag": r.get(TS_FIELDS.get("Omsättning idag",""), ""),
                "TS_Omsättning nästa år": r.get(TS_FIELDS.get("Omsättning nästa år",""), ""),
                "Äldst prognos-TS": oldest.strftime("%Y-%m-%d") if pd.notna(oldest) else "",
                "Saknar prognosvärden?": "Ja" if miss_val else "Nej",
                "Saknar prognos-TS?": "Ja" if miss_ts else "Nej",
            })

    out = pd.DataFrame(rows)
    if out.empty:
        return out
    # sortera på äldst prognos-TS
    out["_sort"] = pd.to_datetime(out["Äldst prognos-TS"], errors="coerce").fillna(pd.Timestamp("2099-12-31"))
    out = out.sort_values(by="_sort", ascending=True).drop(columns=["_sort"])
    if limit and limit > 0:
        out = out.head(limit)
    return out
